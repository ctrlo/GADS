<p></p>
[% FOREACH color IN colors %]
    <div class="timeline-color">
        <div class="timeline-color-key" style="background-color:[% color.color %]"></div>
        <div class="timeline-color-text">[% color.key | html_entity %]</div>
    </div>
[% END %]

<div class="wrapper">
    <div id="loading-div" class="centered-overlay">
         <div class="loader"></div>
    </div>
    <div id="visualization">
    </div>
</div>

<p></p>

<script type="text/javascript">
    var jscode='[% FILTER remove('\n+') %]
        [% FILTER replace('\'', '\\\'') %]
        ( function () {
            var container = document.getElementById('visualization');

            var records_base64 = '[% records %]';
            var json = base64.decode(records_base64);
            var items = new vis.DataSet(JSON.parse(json));
            var groups = '[% groups %]';
            var json_group = base64.decode(groups);
            var groups = JSON.parse(json_group);
            var changed = {};

            var template = Handlebars.templates.timelineitem;

            var save_elem_sel    = '#submit_button',
                cancel_elem_sel  = '#cancel_button',
                changed_elem_sel = '#visualization_changes',
                hidden_input_sel = '#changed_data';

            function before_submit (e) {
                var submit_data = _.mapObject( changed,
                    function( val, key ) {
                        return {
                            column: val.column,
                            current_id: val.current_id,
                            from: val.start.toISOString().substring(0, 10),
                            to:   (val.end || val.start).toISOString().substring(0, 10)
                        };
                    }
                );
                $(window).off('beforeunload');

                [%-# Store the data as JSON on the form %]
                var submit_json = JSON.stringify(submit_data);
                var data_field = $(hidden_input_sel);
                data_field.attr('value', submit_json );
            }

            function on_move (item, callback) {
                changed[item.id] = item;

                var save_button = $( save_elem_sel );
                if ( save_button.is(':hidden') ) {
                    $(window).bind('beforeunload', function(e) {
                        var error_msg = 'If you leave this page your changes will be lost.';
                        if (e) {
                            e.returnValue = error_msg;
                        }
                        return error_msg;
                    });

                    save_button.closest('form').css('display', 'block');
                }

                var changed_item = $('<li>' + item.title + '</li>');
                $( changed_elem_sel ).append(changed_item);

                return callback(item);
            }

            function snap_to_day (datetime, scale, step) {
                return new Date (
                    datetime.getFullYear(),
                    datetime.getMonth(),
                    datetime.getDate()
                );
            }

            function on_select (properties) {
                var items = properties.items;
                if (items.length == 0) {
                    $('.bulk_href').on('click', function(e) {
                        e.preventDefault();
                        alert("Please select some records on the timeline first");
                        return false;
                    });
                } else {
                    var hrefs = [];
                    $("#delete_ids").empty();
                    properties.items.forEach(function(item) {
                        var id = item.replace(/\\+.*/, '');
                        hrefs.push("id=" + id);
                        $("#delete_ids").append('<input type="hidden" name="delete_id" value="' + id + '">');
                    });
                    var href = hrefs.join('&');
                    $('#update_href').attr("href", "/bulk/update/?" + href);
                    $('#clone_href').attr("href", "/bulk/clone/?" + href);
                    $('#count_delete').text(items.length);
                    $('.bulk_href').off();
                }
            }

            [%-# Set up form button behaviour %]
            $( save_elem_sel ).bind( 'click', before_submit );
            $( cancel_elem_sel ).bind( 'click', function (e) {
                $(window).off('beforeunload');
            });

            [%-# See http://visjs.org/docs/timeline/#Editing_Items %]
            var options = {
                [% UNLESS session.rewind %]
                    editable: {
                        add:         false,
                        updateTime:  true,
                        updateGroup: false,
                        remove:      false
                    },
                    multiselect: true,
                [% END %]
                [% IF page_as_mech AND tl_options.width %]
                    width: [% tl_options.width %],
                [% END %]
                [% IF page_as_mech AND tl_options.height %]
                    height: [% tl_options.height %],
                [% END %]
                margin: {
                    item: {
                        horizontal: -1
                    }
                },
                moment: function (date) {
                    return vis.moment(date).utc();
                },
                onMove:   on_move,
                snap:     snap_to_day,
                template: template,
                [% IF timeline.min %]
                    start: "[% timeline.min.ymd %]",
                [% END %]
                [% IF timeline.max %]
                    end: "[% timeline.max.ymd %]",
                [% END %]
                orientation: {axis: "both"}
            };

            var timeline = new vis.Timeline(container, items, options);
            if (groups.length > 0) {
                timeline.setGroups(groups);
            }
            timeline.on('click', function(e) {
                if (!e.item) {
                    $('.item-popup').hide();
                }
                else {
                    var target = $( e.event.target );
                    if (target.hasClass('moreinfo')) {
                        var record_id = target.data('record-id');
                        var m = $("#readmore_modal");
                        m.find('.modal-body').text('Loading...');
                        m.find('.modal-body').load('/record_body/' + record_id);
                        m.modal();
                    } else {
                        target.closest('.vis-item').find('.item-popup').toggle();
                    }
                }
            });
            timeline.on('select', on_select);
            on_select({ items: [] });
            [%# functionality to add new items on range change %]
            var persistent_max;
            var persistent_min;
            timeline.on('rangechanged', function (props) {
                if (!props.byUser) {
                    if (!persistent_min) { persistent_min = props.start.getTime(); }
                    if (!persistent_max) { persistent_max = props.end.getTime(); }
                    return;
                }

                [%# Shortcut - see if we actually need to continue with calculations %]
                if (props.start.getTime() > persistent_min && props.end.getTime() < persistent_max) {
                    update_range_session(props);
                    return;
                }
                $('#loading-div').show();

                [%# Calculate the range of the current items. This will min/max
                    values for normal dates, but for dateranges we need to work
                    out the dates of what was retrieved. E.g. the earliest
                    end of a daterange will be the start of the range of
                    the current items (otherwise it wouldn't have been
                    retrieved)
                %]
                var val = items.min('start');
                var min_start = val ? new Date(val.start) : undefined;
                val = items.max('start');
                var max_start = val ? new Date(val.start) : undefined;
                val = items.min('end');
                var min_end = val ? new Date(val.end) : undefined;
                val = items.max('end');
                var max_end = val ? new Date(val.end) : undefined;
                val = items.min('single');
                var min_single = val ? new Date(val.single) : undefined;
                val = items.max('single');
                var max_single = val ? new Date(val.single) : undefined;
                var have_range = {};
                if (min_end && min_single) {
                    have_range.min = min_end < min_single ? min_end : min_single;
                } else {
                    have_range.min = min_end || min_single;
                }
                if (max_start && max_single) {
                    have_range.max = max_start > max_single ? max_start : max_single;
                } else {
                    have_range.max = max_start || max_single;
                }
                [%# haverange now contains the min and max of the current
                    range. Now work out whether we need to fill to the left or
                    right (or both)
                %]
                if (!have_range.min) {
                    var from = props.start.getTime();
                    var to = props.end.getTime();
                    load_items(from, to);
                }
                if (props.start < have_range.min) {
                    var from = props.start.getTime();
                    var to = have_range.min.getTime();
                    load_items(from, to, "to");
                }
                if (props.end > have_range.max) {
                    var from = have_range.max.getTime();
                    var to = props.end.getTime();
                    load_items(from, to, "from");
                }
                if (!persistent_max || persistent_max < props.end.getTime()) {
                    persistent_max = props.end.getTime();
                }
                if (!persistent_min || persistent_min > props.start.getTime()) {
                    persistent_min = props.start.getTime();
                }

                $('#loading-div').hide();

                [%# leave to end in case of problems rendering this range %]
                update_range_session(props);
            });
            function update_range_session(props) {
                $.post({
                    url: "/[% layout.identifier %]/data_timeline",
                    data: "from=" + props.start.getTime() + "&to=" + props.end.getTime(),
                });
            }
            function load_items(from, to, exclusive) {
                $.ajax({
                    async: false,
                    [%# we use the exclusive parameter to not include ranges
                        that go over that date, otherwise we will retrieve
                        items that we already have
                    %]
                    url: "/[% layout.identifier %]/data_timeline/" + "10" + "?from=" + from + "&to=" + to + "&exclusive=" + exclusive,
                    dataType:'json',
                    success: function(data) {
                        items.add(data);
                    }
                });
            }
        } )();
        [% END %]
    [% END %]';
</script>

<form role="form" method="post" enctype="multipart/form-data" style="display: none" action="/edits">
    <input type="hidden" name="csrf_token" value="[% csrf_token %]">
    <input type="hidden" name="q" id="changed_data">

    <div class="row">
        <div class="col-md-8">
            <div style="height:55px;"></div>
            <nav class="navbar navbar-default navbar-fixed-bottom" style="min-height:55px">
                <div class="container">
                    <button type="submit" id="submit_button" name="submit" value="submit" class="btn btn-primary">Save</button>
                    <a href="/[% layout.identifier %]/data" id="cancel_button" class="btn btn-default">Cancel</a>
                    <span style="padding-left: 35px">You have <a data-toggle="modal" data-target="#modal_changed_items" href="">unsaved changes</a>.</span>
                </div>
            </nav>
        </div>
    </div>

</form>

<div class="modal fade" role="dialog" id="modal_changed_items" tabindex="-1" aria-labelledby="changed_items_title">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                <h4 class="modal-title" id="changed_items_title">Unsaved Changes</h4>
            </div>
            <div class="modal-body">
                <ul class="modal-body" id="visualization_changes">
                </ul>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

[% WRAPPER modal_dialog.tt
    modal_id="modal_png" modal_action_text="View" modal_heading="View timeline as PNG"
    modal_with_form = 1 modal_form_method = "get"
%]
    <input type="hidden" name="png" value="1">
    <div class="form-group">
        <label for="png_height">Height of PNG (pixels):</label>
        <input type="text" class="form-control" name="png_height" value="[% tl_options.height %]">
    </div>
    <div class="form-group">
        <label for="png_width">Width of PNG (pixels):</label>
        <input type="text" class="form-control" name="png_width" value="[% tl_options.width %]">
    </div>
[% END %]
